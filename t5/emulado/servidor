#!/usr/bin/env python3
# Antes de usar, execute o seguinte comando para evitar que o Linux feche
# as conexões TCP que o seu programa estiver tratando:
#
# sudo iptables -I OUTPUT -p tcp --tcp-flags RST RST -j DROP


# Este é um exemplo de um programa que faz eco, ou seja, envia de volta para
# o cliente tudo que for recebido em uma conexão.

import asyncio
from camadarede import CamadaRedeLinux
from mytcp import Servidor as Tcp

DEBUG = True

class Server:
    def __init__(self):
        self.clientes = {}

        if DEBUG:
            print('Iniciando servidor!')

    def dados_recebidos(self,conexao, dados):
        if DEBUG:
            print(conexao, 'recebido',dados)
        if dados == b'':
            if DEBUG:
                src_addr, src_port, _, _ = conexao.id_conexao
                print('Fechando conexão com', f'{src_addr}:{src_port}')

            username = self.clientes[conexao].get('username')

            del self.clientes[conexao]
            conexao.fechar()

            if username:
                msg = f'/quit {username}'
                self.broadcast(msg)

        else:
            dados_decodificados = dados.decode()
            saida_codificada = self.clientes[conexao]['saida'].encode()

            entrada_anterior = self.clientes[conexao].get('entrada', '')
            self.clientes[conexao]['entrada'] = entrada_anterior + dados_decodificados

            conexao.enviar(saida_codificada)

    def conexao_aceita(self, conexao):
        self.clientes[conexao] = {'entrada': '', 'saida': '', 'username': ''}
        conexao.registrar_recebedor(self.dados_recebidos)   # usa esse mesmo recebedor para toda conexão aceita

    def broadcast(self, msg):
        msg_encoded = msg.encode()
        
        for conexao in self.clientes:
            conexao.enviar(msg_encoded)


server = Server()
rede = CamadaRedeLinux()
tcp = Tcp(rede, 7000)
tcp.registrar_monitor_de_conexoes_aceitas(server.conexao_aceita)
asyncio.get_event_loop().run_forever()
