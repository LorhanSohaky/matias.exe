#!/usr/bin/python3

import select
import socket
import threading


HOST = 'localhost'
PORT = 7000
MAX_LISTEN = 5
END_OF_MESSAGE = b'\n'
MAX_BUFFER_SIZE = 6144


class Server:
    def __init__(self):
        print('Iniciando servidor!')
        self.clients = []
        self.clients_ready_to_response = []
        self.inputs = {}
        self.outputs = {}
        self.usernames = {}
        self.socket_server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        # Do not use SO_REUSEADDR in production enviroment
        self.socket_server.setsockopt(
            socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        self.socket_server.bind((HOST, PORT))
        self.socket_server.listen(MAX_LISTEN)

    def accept_connection(self):
        connection = self.socket_server.accept()[0]
        self.clients.append(connection)
        self.inputs[connection] = b''

    def response_clients(self):
        for client in self.clients_ready_to_response:
            data = self.inputs.get(client, b'')
            while END_OF_MESSAGE in data:
                self.send_message(client)
                data = data[data.index(END_OF_MESSAGE)+1:]

            self.inputs[client] = b''
            self.clients_ready_to_response.remove(client)

    def send_message(self, client):
        connection = client
        self.protocol(client)
        message = self.outputs[client]
        connection.send(message)

    def read_message(self, client):
        connection = client

        input_data = connection.recv(2048)
        previous_data = self.inputs[connection]
        data = previous_data + input_data

        # Check size to prevent overflow
        if len(data) >= MAX_BUFFER_SIZE:
            data = input_data

        self.inputs[connection] = data

        if data.find(END_OF_MESSAGE) != -1:
            self.clients_ready_to_response.append(connection)
        elif len(input_data) == 0:
            connection.close()
            self.clients.remove(client)

    def multiplex_client(self):
        sockets = self.clients
        sockets.append(self.socket_server)
        while sockets:
            ready_to_read, ready_to_write, exception = select.select(
                sockets, self.clients_ready_to_response, [])

            for socket in ready_to_read:
                if socket is self.socket_server:
                    self.accept_connection()
                else:
                    self.read_message(socket)

            self.response_clients()
            sockets = self.clients

    def has_clients(self):
        return len(self.clients)

    def protocol(self, client):
        if self.inputs[client].startswith(b'/nick'):
            self.inputs[client] = b''.join(
                self.inputs[client].split(b'/nick '))
            if b':' in self.inputs[client] or b' ' in self.inputs[client]:
                self.outputs[client] = b'/error\n'
            elif self.inputs[client] in self.usernames.values():
                self.outputs[client] = b'/error\n'
            else:
                message = b''
                if client in self.usernames:
                    message = b'/renamed', self.usernames[client].replace(
                        b'\n', b''), self.inputs[client]
                else:
                    message = b'/joined', self.inputs[client]
                message = b' '.join(message)
                self.usernames[client] = self.inputs[client]
                self.broadcast(message)
        else:
            if client in self.usernames:
                message = self.usernames[client].replace(
                    b'\n', b''), self.inputs[client]
                message = b': '.join(message)
                self.broadcast(message)
            else:
                self.outputs[client] = b'/error\n'

    def broadcast(self, message):
        for client in self.clients:
            self.outputs[client] = message
            if client not in self.clients_ready_to_response:
                self.clients_ready_to_response.append(client)


def main():
    server = Server()
    server.multiplex_client()


if __name__ == '__main__':
    main()
